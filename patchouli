#!/usr/bin/env python3

from pathlib import Path
import re
import shutil
import requests
import argparse
from typing import Callable, NoReturn, TypedDict, cast, NotRequired


VERSION = "v0.1.0"
APP_NAME = "patchouli"
DEVELOPER = "Avimitin"
GITHUB = "https://github.com/Avimitin/patchouli"
UA = f"{DEVELOPER}/{APP_NAME}/{VERSION} ({GITHUB})"

API_URL = "https://api.bangumi.com"


class Task:
    description: str
    operation: Callable[[], None]

    def __init__(self, desc: str, op: Callable[[], None]) -> None:
        self.description = desc
        self.operation = op

    def __str__(self) -> str:
        return self.description

    def run(self) -> None:
        return self.operation()


def bail(s: str, code: int = 1) -> NoReturn:
    """
    Print error message and exit with custom exit code.

    Args:
        s: The message to report.
        code: The exit code, default exit with 1.
    """
    print(f"ERROR: {s}")
    exit(code)


def cli_check(exec: str) -> str:
    """
    Check CLI existence and bail out when not found. Return full path to the CLI.

    Args:
        exec: CLI name to search in system.
    """
    path = shutil.which(exec)
    if path is None:
        bail(f"{exec} not found in system")
    return path


def guess_vol(filename: str) -> int | None:
    """
    Match volume filename with following pattern:
        * name - 卷01...
        * name - 卷 01...
        * name - Vol.01...
        * name - Vol01...
        * name - Vol 01...
        * name - 01...

    Args:
        filename: The name of the manga file, don't pass full path.
    """
    capture = re.search(r"-\s*卷\s*(\d+)", filename)
    if capture is not None:
        return int(capture.group(1))

    capture = re.search(r"-\s*Vol\.(\d+)", filename)
    if capture is not None:
        return int(capture.group(1))

    capture = re.search(r"-\s*Vol\s*(\d+)", filename)
    if capture is not None:
        return int(capture.group(1))

    capture = re.search(r"-\s*(\d+)", filename)
    if capture is not None:
        return int(capture.group(1))


class BgmSubjectTag(TypedDict):
    name: str
    count: str


class BgmSubjectInfobox(TypedDict):
    key: str
    value: str


class BgmSubjectResp(TypedDict):
    id: int
    series: bool
    platform: str
    date: str
    name: str
    name_cn: str
    tags: list[BgmSubjectTag]
    meta_tags: list[str]
    infobox: list[BgmSubjectInfobox]


def get_bangumi_subject(subject_id: int) -> BgmSubjectResp:
    """
    Fetches subject details from the Bangumi API.

    Args:
        subject_id: The integer ID of the subject to fetch.
    """
    endpoint = f"/v0/subjects/{subject_id}"
    url = API_URL + endpoint
    headers = {"User-Agent": UA}

    try:
        response = requests.get(url, headers=headers, timeout=20)
        response.raise_for_status()

        return cast(BgmSubjectResp, response.json())
    except requests.exceptions.HTTPError as http_err:
        bail(f"HTTP error occurred: {http_err}")
    except requests.exceptions.ConnectionError as conn_err:
        bail(f"Error connecting: {conn_err}")
    except requests.exceptions.Timeout as timeout_err:
        bail(f"Request timed out: {timeout_err}")
    except requests.exceptions.RequestException as req_err:
        bail(f"An unexpected error occurred: {req_err}")
    except ValueError:
        bail(f"Could not decode JSON response. Send issue at {GITHUB}")


class BgmSearchResp(TypedDict):
    data: list[BgmSubjectResp]


class BgmSearchFilter(TypedDict):
    type: list[int]
    nsfw: bool


class BgmSearchPayload(TypedDict):
    keyword: str
    sort: str
    filter: BgmSearchFilter


def search_bangumi_subjects(search_payload: BgmSearchPayload) -> BgmSearchResp:
    """
    Sends a search request to the Bangumi API with a JSON payload.

    Args:
        search_payload: A dictionary containing the search criteria.
        user_agent: The custom User-Agent string to send with the request.
    """
    endpoint = "/v0/search/subjects"
    url = API_URL + endpoint
    headers = {"User-Agent": UA, "Content-Type": "application/json"}

    try:
        response = requests.post(url, headers=headers, json=search_payload, timeout=20)
        response.raise_for_status()

        # Parse the response as JSON
        return cast(BgmSearchResp, response.json())
    except requests.exceptions.HTTPError as http_err:
        bail(f"HTTP error occurred: {http_err}")
    except requests.exceptions.ConnectionError as conn_err:
        bail(f"Error connecting: {conn_err}")
    except requests.exceptions.Timeout as timeout_err:
        bail(f"Request timed out: {timeout_err}")
    except requests.exceptions.RequestException as req_err:
        bail(f"An unexpected error occurred: {req_err}")
    except ValueError:
        bail(f"Could not decode JSON response from server. Send issue at {GITHUB}")


class BgmRelationResp:
    name: str
    relation: str
    type: int
    id: int


def get_bangumi_subject_relation(subject_id: int) -> list[BgmRelationResp]:
    """
    Fetches subject relation from the Bangumi API.

    Args:
        subject_id: The integer ID of the subject to fetch.
    """
    endpoint = f"/v0/subjects/{subject_id}/subjects"
    url = API_URL + endpoint
    headers = {"User-Agent": UA}

    try:
        response = requests.get(url, headers=headers, timeout=20)
        response.raise_for_status()

        return cast(list[BgmRelationResp], response.json())
    except requests.exceptions.HTTPError as http_err:
        bail(f"HTTP error occurred: {http_err}")
    except requests.exceptions.ConnectionError as conn_err:
        bail(f"Error connecting: {conn_err}")
    except requests.exceptions.Timeout as timeout_err:
        bail(f"Request timed out: {timeout_err}")
    except requests.exceptions.RequestException as req_err:
        bail(f"An unexpected error occurred: {req_err}")
    except ValueError:
        bail(f"Could not decode JSON response. Send issue at {GITHUB}")


def build_lookup_dir_task(d: str):
    manga_dir = Path(d)
    if not manga_dir.exists:
        bail(f"Path {d} does not exist")
    if not manga_dir.is_dir():
        bail(f"Path {d} is not a directory")

    # Only read top-level items
    child_items = list(manga_dir.iterdir())
    item_count = len(child_items)

    def searcher():
        # Use dirname to search
        MANGA_TYPE = 1
        search_result = search_bangumi_subjects(
            {
                "keyword": manga_dir.name,
                "sort": "rank",
                "filter": {"type": [MANGA_TYPE], "nsfw": False},
            }
        )


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="A tool to bridge import Bangumi metadata to Calibre",
        prog=APP_NAME,
    )
    subparsers = parser.add_subparsers(
        dest="command", help="Available commands", required=True
    )
    addp = subparsers.add_parser("add", help="Add new manga")
    addp.add_argument("path", help="Path to the manga directory")
    addp.add_argument(
        "--prefer-cn-name",
        action="store_true",
        help="Prefer using Chinese translated name as title",
    )
    # TODO: use a event queue for dry run to print job sequence
    addp.add_argument(
        "--dry-run",
        action="store_true",
        help="TODO: Print job sequence instead of execute it",
    )
    addp.add_argument(
        "--query-only",
        action="store_true",
        help="Query metadata and print metadata, but don't acutally add books to Calibre",
    )

    # prefer_cn_name: bool
    # prefer_meta_tags: bool
    # meta_tag_least_count: int
    # auto_reject_non_manga: bool

    try:
        args = parser.parse_args()
        return args
    except argparse.ArgumentError:
        parser.print_help()
        exit(0)


class CalibreAddConfig(TypedDict):
    parent: Path
    file_path: Path

    title: str
    authors: list[str]
    isbn: NotRequired[str]
    tags: list[str]
    series: NotRequired[str]
    series_index: NotRequired[int]
    cover: NotRequired[str]
    languages: list[str]


def config_to_args(cfg: CalibreAddConfig, extra_db_args: list[str]) -> list[str]:
    args: list[str] = []
    args += ["-t", cfg["title"]]

    authors = ",".join(cfg["authors"])
    args += ["-a", authors]

    isbn = cfg.get("isbn")
    if isbn is not None:
        args += ["-i", isbn]

    tags = ",".join(cfg["tags"])
    args += ["-T", tags]

    series = cfg.get("series")
    if series is not None:
        args += ["-s", series]

    series_index = cfg.get("series_index")
    if series_index is not None:
        args += ["-S", series_index]

    cover_image = cfg.get("cover")
    if cover_image is not None:
        args += ["-c", cover_image]

    return args + extra_db_args + [str(cfg["file_path"])]


def run_add(args: argparse.Namespace):
    pass


# TODO
if __name__ == "__main__":
    args = parse_args()
    if args.command == "add":
        run_add(args)
    else:
        bail("internal error: unreachable")
